
// ************* AI - NEOLOGISM EXPERIMENT ****************
// MINIMAL Neural Network example, for wordcrafting study.
//   - generated by Claude, revised by Gemini.
//   - trains an NN then AFFIRMS presence in nn.
//------------------------------------------------------
// VARIANT: 10X10 aZ targets (sigmoid pre relu)
// - with LOCAL VIZ module, variations.
// - ADD: TRAIN BTN and COMBOS for LR and EPOCH
// - ADD: 10 FRAME TIMELINE - METADATA.
// - USE: 10 FRAME DATA for AI_MOVIE.
// TODO: -------------------------------
// O - AI_HYPER_PARAMS
// O - AI_BRAINZ (meta data)
// O - AI_TIMELINE
// O - AI_MOVIE
//----------------------UI-VARIABLES--------------
const NNTXT_1_ELEM = document.getElementById("NNTXT_1_ELEM");
const OUTPUT_1_ELEM = document.getElementById("OUTPUT_1_ELEM");
const TXT_INPUT_1_ELEM = document.getElementById('TXT_INPUT_1_')
const TEST_BTN_1_ELEM = document.getElementById('TEST_BTN_1_')
//-----------------------------------------------
//------------------------VISUALIZATION-----------
import { AI_VIZ_LOG } from './module_AI_VIZ_LOG_1.js';
// import { AI_BRAIN_VIZ_1 } from './module_ai_BRAIN_VIZ_1.js';
// const CANVAS_1_ELEM = document.getElementById('CANVAS_BRAIN_VIZ_1');
const CANVAS_BRAIN_VIZ_1 = document.getElementById('CANVAS_BRAIN_VIZ_1');
//-----------------------------------------------
class NeuralNetwork_aZ_1 {
    constructor(inputSize,learnRate,epochRate) {
        // Making square matrices (equal dimensions)
        this.inputSize = inputSize;
        this.hiddenSize = inputSize;
        this.outputSize = 2;  // Two outputs: starts with 'a' and contains uppercase

        // Initialize weights with improved initial values for better convergence
        this.weightsIH = this.initializeWeights(this.inputSize, this.hiddenSize, 0.3);
        this.weightsHO = this.initializeWeights(this.hiddenSize, this.outputSize, 0.3);
        
        // Initialize biases with small positive values
        this.biasH = new Array(this.hiddenSize).fill(0.1);
        this.biasO = new Array(this.outputSize).fill(0.1);
        
        console.log('LEARN RATE',learnRate)
        // Learning parameters
        this.learningRate = (learnRate)?learnRate:0.15;  // Tuned for better convergence
        this.epochRate = epochRate; //pass through to VIZ.
    }

    // Initialize weights with Xavier initialization
    initializeWeights(rows, cols, scale) {
        const weights = [];
        for (let i = 0; i < rows; i++) {
            weights[i] = [];
            for (let j = 0; j < cols; j++) {
                // Xavier initialization: variance of weights based on layer size
                weights[i][j] = (Math.random() * 2 - 1) * Math.sqrt(scale / rows);
            }
        }
        return weights;
    }

    // Sigmoid activation function
    sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
    }

    // Derivative of sigmoid for backpropagation
    sigmoidDerivative(x) {
        return x * (1 - x);
    }

    // Convert word to input vector (using ASCII values normalized)
    wordToInput(word, size) {
        const input = new Array(size).fill(0);
        for (let i = 0; i < Math.min(word.length, size); i++) {
            input[i] = word.charCodeAt(i) / 255;  // Normalize ASCII values
        }
        return input;
    }
    // Convert letter sequence to input vector
    // Each position represents presence (1) or absence (0) of a letter
    // tokenToInput(token) {
        
    //     const input = Array(26 * 2).fill(0); // Space for 2 letters
    //     for (let i = 0; i < Math.min(token.length, 2); i++) {
    //         const charCode = token.charCodeAt(i) - 97; // 'a' starts at 97
    //         if (charCode >= 0 && charCode < 26) {
    //             input[i * 26 + charCode] = 1;
    //         }
    //     }
    //     AI_VIZ_LOG('-🤖 TOKEN_VECTOR 🤖',token)
    //         //TODO VECTOR DETECTOR
    //         // AI_VIZ_LOG("\n--🔬 VIZ: VECTOR _DETECTOR 🔬");
    //         //AI_VIZ_BRAIN.VECTOR_DETECTOR(input,token)

    //     return input;
    // }

    // Forward pass through the network
    forward(input) {
        // Hidden layer computations
        this.hiddenLayer = new Array(this.hiddenSize).fill(0);
        for (let i = 0; i < this.hiddenSize; i++) {
            let sum = this.biasH[i];
            for (let j = 0; j < this.inputSize; j++) {
                sum += input[j] * this.weightsIH[j][i];
            }
            this.hiddenLayer[i] = this.sigmoid(sum);
        }

        // Output layer computations
        this.outputLayer = new Array(this.outputSize).fill(0);
        for (let i = 0; i < this.outputSize; i++) {
            let sum = this.biasO[i];
            for (let j = 0; j < this.hiddenSize; j++) {
                sum += this.hiddenLayer[j] * this.weightsHO[j][i];
            }
            this.outputLayer[i] = this.sigmoid(sum);
        }

        return this.outputLayer;
    }

    // Backward pass for training
    backward(input, target, output) {
        // Output layer error
        const outputErrors = new Array(this.outputSize);
        for (let i = 0; i < this.outputSize; i++) {
            outputErrors[i] = (target[i] - output[i]) * this.sigmoidDerivative(output[i]);
        }

        // Hidden layer error
        const hiddenErrors = new Array(this.hiddenSize).fill(0);
        for (let i = 0; i < this.hiddenSize; i++) {
            for (let j = 0; j < this.outputSize; j++) {
                hiddenErrors[i] += outputErrors[j] * this.weightsHO[i][j];
            }
            hiddenErrors[i] *= this.sigmoidDerivative(this.hiddenLayer[i]);
        }

        // Update weights and biases
        // Hidden to output weights
        for (let i = 0; i < this.hiddenSize; i++) {
            for (let j = 0; j < this.outputSize; j++) {
                this.weightsHO[i][j] += this.learningRate * outputErrors[j] * this.hiddenLayer[i];
            }
        }

        // Input to hidden weights
        for (let i = 0; i < this.inputSize; i++) {
            for (let j = 0; j < this.hiddenSize; j++) {
                this.weightsIH[i][j] += this.learningRate * hiddenErrors[j] * input[i];
            }
        }

        // Update biases
        for (let i = 0; i < this.outputSize; i++) {
            this.biasO[i] += this.learningRate * outputErrors[i];
        }
        for (let i = 0; i < this.hiddenSize; i++) {
            this.biasH[i] += this.learningRate * hiddenErrors[i];
        }
    }

    // Training function
    train(inputs, targets, epochs) {
        const errors = [];
        for (let epoch = 0; epoch < epochs; epoch++) {
            let epochError = 0;
            for (let i = 0; i < inputs.length; i++) {
                const output = this.forward(inputs[i]);
                this.backward(inputs[i], targets[i], output);
                
                // Calculate mean squared error
                for (let j = 0; j < this.outputSize; j++) {
                    epochError += Math.pow(targets[i][j] - output[j], 2);
                }
            }
            epochError /= inputs.length;
            errors.push(epochError);
            
            // Early stopping if error is small enough
            if (epochError < 0.001) break;
        }
        return errors; //TODO: visualize 1000 returns, to show TRAINING MOVIE.
        //TODO: then use BACKTRACE to
    }

    // Visualize network state
    visualize() {
        console.log("\nNeural Network State:");
        console.log("Input -> Hidden Weights:");
        console.log(this.weightsIH.map(row => row.map(w => w.toFixed(3))));
        console.log("\nHidden -> Output Weights:");
        console.log(this.weightsHO.map(row => row.map(w => w.toFixed(3))));
        console.log("\nHidden Biases:", this.biasH.map(b => b.toFixed(3)));
        console.log("Output Biases:", this.biasO.map(b => b.toFixed(3)));
    }
    // Train the network using backpropagation
    // train(input, target) { //target array of target types.
    //     // Forward pass
    //     AI_VIZ_LOG('--🏈 FORWARD_PASS 🏈')
    //     this.forward(input); //this.output

    //     // Output layer error
    //     const outputErrors = target.map((t, i) => (t - this.output[i]));
    //     AI_VIZ_LOG('--HL: OUTPUT ERROR')
    //     AI_VIZ_LOG('--OL: ERROR')
        
    //     // Hidden layer error
    //     const hiddenErrors = this.hidden.map((_, i) => {
    //         let error = 0;
    //         for (let j = 0; j < outputErrors.length; j++) {
    //             error += outputErrors[j] * this.weightsHO[i][j];
    //         }
    //         return error;
    //     });

    //     // Update weights and biases
    //     AI_VIZ_LOG('-Update WEIGHT/BIAS/Learn',this.learningRate)
    //     // Output layer
    //     for (let i = 0; i < this.hidden.length; i++) {
    //         for (let j = 0; j < this.output.length; j++) {
    //             this.weightsHO[i][j] += this.learningRate * outputErrors[j] * 
    //                 this.output[j] * (1 - this.output[j]) * this.hidden[i];
    //         }
    //     }

    //     // Hidden layer
    //     for (let i = 0; i < input.length; i++) {
    //         for (let j = 0; j < this.hidden.length; j++) {
    //             this.weightsIH[i][j] += this.learningRate * hiddenErrors[j] * 
    //                 this.hidden[j] * (1 - this.hidden[j]) * input[i];
    //         }
    //     }

    //     // Update biases
    //     for (let i = 0; i < this.biasO.length; i++) {
    //         this.biasO[i] += this.learningRate * outputErrors[i] * 
    //             this.output[i] * (1 - this.output[i]);
    //     }
    //     for (let i = 0; i < this.biasH.length; i++) {
    //         this.biasH[i] += this.learningRate * hiddenErrors[i] * 
    //             this.hidden[i] * (1 - this.hidden[i]);
    //     }
    // }
} //END NEURAL NETWORK class

//------------------------------------UI--------
function queryNeuralNetwork_1_(e){
    // if(!TXT_INPUT_1_ELEM){console.log('err: missing input'); return}
    // const val = TXT_INPUT_1_ELEM.value;
    // if(!val){console.log('needs input'); return;}
    // tokens = val.split(' '); // MULTIPLE INPUT (token test) BY SPACE
    // OUTPUT_1_ELEM.innerHTML = ''; //clear out put
    // tokens.forEach(token => {
    //     const input = nn_1.tokenToInput(token);
    //     const output = nn_1.forward(input);
    //     console.log(`Token: ${token}, Output: ${output.map(v => v.toFixed(3))}`);
    //     // debugger;
    //     const txtPCTS = output.map( (v) => { 
    //         // return v.toFixed(3); 
    //         return v.toFixed(2)*100;
    //         // let decimal = v.toFixed(2)*100;
    //         // return decimal.toFixed(0)+'%'; //human readable %
    //     });
    //     // const txtPCTS = txtTOKENS.split(',')
    //     if(txtPCTS[0]<txtPCTS[1]){//YES
    //         OUTPUT_1_ELEM.innerHTML += `${token} || NO: ${txtPCTS[1]} || yes: ${txtPCTS[0]}<br>`;
    //     } else { //NO
    //         OUTPUT_1_ELEM.innerHTML += `${token} || YES: ${txtPCTS[0]} || no: ${txtPCTS[1]}<br>`;
    //     }
    //     // OUTPUT_1_ELEM.innerHTML = `${token}||${txtROW}||${1234}`;
    // });
}
TEST_BTN_1_ELEM.onclick = queryNeuralNetwork_1_;
//-----------END UI-----------------------------
//-----------AI RUNNER-----------------------------
// Test the neural network
let nn;//connect to viz.
function testNetwork() {
    // debugger;
    // // Convert word to input vector (using ASCII values normalized)
    // function wordToInput(word, size) {
    //     const input = new Array(size).fill(0);
    //     for (let i = 0; i < Math.min(word.length, size); i++) {
    //         input[i] = word.charCodeAt(i) / 255;  // Normalize ASCII values
    //     }
    //     return input;
    // }

    // Create training data
    const trainingWords = [
        "apple", "Banana", "cat", "Dog", "elephant",
        "art", "Book", "car", "Door", "egg",
        "another", "CAPS", "simple", "Test", "animal"
    ];

    //----TUNABLE---HYPER_PARAMS:-----------------
    const learnRate = 0.1544;
    const epoch_NUM = 10000; 
    const inputSize = 10;  // Fixed input size
    nn = new  NeuralNetwork_aZ_1(inputSize, learnRate, epoch_NUM);

    // Prepare training data
    const inputs = trainingWords.map(word => nn.wordToInput(word, inputSize));
    const targets = trainingWords.map(word => [
        word.startsWith('a') ? 1 : 0,
        /[A-Z]/.test(word) ? 1 : 0
    ]); //TODO extend with count>3 and ends with little a.

    // Train the network
    console.log("Training network...");
    const errors = nn.train(inputs, targets, epoch_NUM);
    console.log("Final error:", errors[errors.length - 1]);

    // Test the network
    const testWords = ["amazing", "and", "zebra", "Apple", "test"];
    console.log("\nTesting network:");
    for (const word of testWords) {
        const input = nn.wordToInput(word, inputSize);
        const output = nn.forward(input);
        console.log(`\nWord: ${word}`);
        console.log(`Starts with 'a': ${output[0].toFixed(3)} (Expected: ${word.startsWith('a') ? 1 : 0})`);
        console.log(`Contains uppercase: ${output[1].toFixed(3)} (Expected: ${/[A-Z]/.test(word) ? 1 : 0})`);
    }

    // Visualize the final state
    // nn.visualize();
}

// Run the test
testNetwork();
//-----------END AI RUNNER-----------------------------
//----------- AI_BRAIN_VIZ-----------------------------
export class AI_BRAIN_VIZ_2 {
    constructor(neuralNet,canvasElem) {
        // Select the canvas and get its 2D rendering context
        if(!neuralNet){console.log('err: no network')}
        this.neuralNet = neuralNet;
        if(!canvasElem){console.log('err: no canvas')}
        this.canvas = canvasElem;//document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        // debugger;
        // this.canvas.width = 500; //default width
        // debugger;
    //epoch this.neuralNet.epoch_NUM
        // this.canvas.width = canvasElem.width
        // this.canvas.height = canvasElem.height
        // this.canvas.width = canvasElem.parentElement.clientWidth * 0.8;
        // this.canvas.height = 200; //default height

    }
    
    // render_BASELINE(epochz = []) { //TODO: timeline
    //     // Clear the canvas
    //     // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    //     // this.canvas.width = (epochz.length)?epochz.length*100:300;
    //     // Draw base timeline
    //     this.ctx.beginPath();
    //     this.ctx.strokeStyle = 'steelblue';
    //     this.ctx.lineWidth = 1;
    //     this.ctx.moveTo(25, this.canvas.height * 0.6 );
    //     this.ctx.lineTo(this.canvas.width - 25, this.canvas.height * 0.6 );
    //     this.ctx.stroke();

    //     let epoch = {};
    //     for(var i=0; i<epochz.length;i++){
    //         epoch = epochz[i];
    //         // console.log('EPOCH',epoch.title,(i+1)*10)
    //         this.DRAW_VERTICAL_LINE(((i+1)*100)+14);
    //         // this.DRAW_VERTICAL_LINE(epoch.x);
    //         // this.DRAW_POINT(epoch.x, epoch.y, epoch.emoji);
            
    //     }

    // }

    // DRAW_VERTICAL_LINE(x) {
    //     this.ctx.beginPath();
    //     this.ctx.strokeStyle = 'steelblue';
    //     this.ctx.moveTo(x, this.canvas.height * 0.6 - 10 );
    //     this.ctx.lineTo(x, this.canvas.height * 0.6 + 10);
    //     this.ctx.lineWidth = 1;
    //     this.ctx.stroke();
    // }

    // render_EPOCHZ(epochz) { 
    //     epochz.forEach(epoch => {
    //         // console.log('EPOCH',epoch.title)
    //         // this.DRAW_VERTICAL_LINE(epoch.x);
    //         this.DRAW_POINT(epoch.x, epoch.y, epoch.emoji);
    //     });
    // }

    render_NEURON_WEIGHTS(){ //NEURON_WEIGHT VIZ.
        // debugger;
        // this.neuralNet;
        // NN_MIN1:biasH, biasO, hidden, learningRate, output, weightsHO, weightsIH

        

        // this.neuralNet.weightsIH 10x2
        // this.neuralNet.weightsHO 52x10
        let frame=[],vector=[],scalar=0;
        let rows=0,cols=0;
        let SIZE_SML=2,SIZE_BIG=4,SPACING_SML=6,SPACING_BIG=8;
        let startX=0,startY=0,colorVal='';;

        let PAD_TOP = 25;
        let PAD_LEFT = 20;
        let CURSOR_POS = {x:PAD_LEFT,y:PAD_TOP}; //USE like a ink printer.
        // let DOT_SIZE = 4;


        // this.ctx.fillStyle = 'steelblue';
        // this.ctx.font = "0.888em Arial italic bold "; //TITLE
        // this.ctx.fillText("HYPERPARAMS:", CURSOR_POS.x, CURSOR_POS.y);
        
        // CURSOR_POS = {x:PAD_LEFT,y:60}; //NEXT POSITION.

        this.ctx.fillStyle = 'steelblue';
        this.ctx.font = "0.8em Arial italic bold "; //TITLE
        this.ctx.fillText("NEURON IH:", CURSOR_POS.x, CURSOR_POS.y);

        CURSOR_POS = {x:166,y:18}; //NEXT POSITION.

        rows = this.neuralNet.weightsIH.length;
        for (let frameIDX = 0; frameIDX < this.neuralNet.weightsIH.length; frameIDX++) {
            frame = this.neuralNet.weightsIH[frameIDX];
            cols = frame.length;
            // startX = PAD_LEFT + (frameIDX*spacing); 
            startX = CURSOR_POS.x + (frameIDX*SPACING_BIG); 
            for (let vectorIDX = 0; vectorIDX < frame.length; vectorIDX++) {
                vector = frame[vectorIDX];
                // startX += vectorIDX * spacing;
                startY = CURSOR_POS.y + (vectorIDX * SPACING_BIG);
                // startY = PAD_LEFT + (vectorIDX * spacing) + CURSOR_POS.y;
                colorVal = this.getColor_MAP_1(vector,-1,1)
                 // this.DRAW_POINT( startX + i * spacing, startY   );
                // console.log('point',startX,startY)
                this.ctx.beginPath();

                this.ctx.fillStyle = colorVal;
                // this.ctx.fillStyle = 'blue';
                this.ctx.arc(startX, startY,SIZE_BIG, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
        CURSOR_POS = {x:PAD_LEFT,y:66}; //NEXT POSITION.
        this.ctx.fillStyle = 'steelblue';
        this.ctx.font = "0.8em Arial italic bold "; //TITLE
        this.ctx.fillText("NEURON HO:",CURSOR_POS.x,CURSOR_POS.y);
        // CURSOR_POS = {x:0,y:CURSOR_POS.y + 75}
        CURSOR_POS = {x:PAD_LEFT+20,y:60}; //NEXT POSITION.
        rows = this.neuralNet.weightsHO.length;
        for (let frameIDX = 0; frameIDX < this.neuralNet.weightsHO.length; frameIDX++) {
            frame = this.neuralNet.weightsHO[frameIDX];
            cols = frame.length;
            startX = CURSOR_POS.x + (frameIDX*SPACING_SML);// + CURSOR_POS.x; 
            for (let vectorIDX = 0; vectorIDX < frame.length; vectorIDX++) {
                vector = frame[vectorIDX];
                // startX += vectorIDX * spacing;
                startY = PAD_TOP + (vectorIDX * SPACING_SML) +CURSOR_POS.y;
                colorVal = this.getColor_MAP_1(vector,-1,1)
                 // this.DRAW_POINT( startX + i * spacing, startY   );
                // console.log('point',startX,startY)
                this.ctx.beginPath();

                this.ctx.fillStyle = colorVal;
                // this.ctx.fillStyle = 'blue';
                this.ctx.arc(startX, startY,SIZE_SML, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }        
        // debugger;
        this.ctx.fillStyle = 'steelblue';
        this.ctx.font = "0.8em Arial italic bold "; //TITLE
        this.ctx.fillText("BIAS(hidden):", PAD_LEFT, 120);

        CURSOR_POS = {x:166,y:120}; //NEXT POSITION.
        // CURSOR_POS = {x:0,y:CURSOR_POS.y + 40}
        rows = 1;
        for (let vectorIDX = 0; vectorIDX < this.neuralNet.biasH.length; vectorIDX++) {
            scalar = this.neuralNet.biasH[vectorIDX];
            startX = CURSOR_POS.x + vectorIDX * SPACING_SML;
            startY = CURSOR_POS.y;
            colorVal = this.getColor_MAP_1(scalar,-1,1)
            this.ctx.beginPath();
            this.ctx.fillStyle = colorVal;
            // console.log('point',startX,startY)
            this.ctx.arc(startX, startY,SIZE_SML, 0, Math.PI * 2);
            this.ctx.fill();
        }

        // debugger;
        // CURSOR_POS = {x:PAD_LEFT+100,y:120}; //NEXT POSITION.
        // this.ctx.fillStyle = 'steelblue';
        // this.ctx.font = "0.8em Arial italic bold "; //TITLE
        // this.ctx.fillText("Output", PAD_LEFT, CURSOR_POS.y);

        // CURSOR_POS = {x:PAD_LEFT,y:110}; //NEXT POSITION.
        // // CURSOR_POS = {x:0,y:CURSOR_POS.y + 40}
        // rows = 1;
        // for (let vectorIDX = 0; vectorIDX < this.neuralNet.outputLayer.length; vectorIDX++) {
        //     scalar = this.neuralNet.outputLayer[vectorIDX];
        //     startX = CURSOR_POS.x + (vectorIDX * 40);
        //     startY = CURSOR_POS.y;
        //     colorVal = this.getColor_MAP_1(scalar,-1,1)
        //     this.ctx.fillStyle = colorVal;
        //     this.ctx.font = "0.6em Arial italic bold "; //TITLE
        //     this.ctx.fillText(scalar.toFixed(2), startX, startY);
        // }
    }

    getColor_MAP_1 (value, min, max){ // Map value to color intensity
        // if(value<min){console.log('warning: color less than min',min,value)}
        // if(value>max){console.log('warning: color more than max',max,value)}
        const normalized = (value - min) / (max - min);
        let r = Math.floor(255 * (1 - normalized));
        let b = Math.floor(255 * normalized);
        //TODO: cannot be negative?
        r = (r<0)?0:r;
        b = (b<0)?0:b;
        return (value===0)?'black':(b>r)?'blue':'red';
    }

    // DRAW_GRID(grid = {rows : 14, cols : 14, startX : 30, startY : 30, spacing : 4} ) {
    //     // console.log('grid', rows, cols, startX, startY, spacing);
    //     for (let row = 0; row < grid.rows; row++) {
    //         this.DRAW_VECTOR(
    //             grid.startX, 
    //             grid.startY + row * grid.spacing, 
    //             grid.cols, 
    //             grid.spacing
    //         );
    //     }
    // }

    // DRAW_VECTOR(startX, startY, count = 10, spacing = 10) {
    //     // console.log('vector', startX, startY, count, spacing);
    //     for (let i = 0; i < count; i++) {
    //         this.DRAW_POINT( startX + i * spacing, startY   );
    //     }
    // }

    // DRAW_POINT(x, y) {
    //     // console.log('point',x,y)
    //     this.ctx.beginPath();
    //     this.ctx.fillStyle = 'blue';
    //     this.ctx.arc(x, y, 1, 0, Math.PI * 2);
    //     this.ctx.fill();
    // }
    
    // DRAW_EMOJI(x, y, emoji) {
    //     console.log('emoji',x,y)
    //     // Draw emoji
    //     this.ctx.font = '12px Arial';
    //     this.ctx.fillStyle = 'white'; // Ensure visibility on black background
    //     // this.ctx.textAlign = 'center';
    //     this.ctx.fillText(emoji, x, y);
    // }
}
//-----------------------------LOCAL MODULE: 
//- add vis features here, then export to module.

function RENDER_BRAIN_VIZ(){ //VIZ MODULE-RUNNER
    if(!nn || !CANVAS_BRAIN_VIZ_1){ console.log('ERROR: no neural net for viz');return}
    const AI_BRAIN_VIZ = 
    new AI_BRAIN_VIZ_2(nn,CANVAS_BRAIN_VIZ_1);
    
    // 1. Initial Weight Visualization (Before Training)
    AI_VIZ_LOG("---🔬 VIZ: AI_BRAIN 🔬");
    AI_BRAIN_VIZ.render_NEURON_WEIGHTS(); //visualizeWeights
    // AI_BRAIN_VIZ.render_BASELINE([{title:'a',title:'b'}])
    // AI_BRAIN_VIZ.render_BASELINE([{title:'a',title:'b'}])


}; RENDER_BRAIN_VIZ();
//-----------END AI VIZ-----------------------------

// let nn_1;
// // TOKENS STRONGER UP FRONT with MORE EPOCH, less with less epoch.
// // let tokens = ["aa", "ab", "abc", "aaa", "bb", "ba", "ab", "abb", "bbb"];
// let tokens = ["aa", "ab", "abc", "aaa", "bb", "ff", "xxx", "abb", "bbb"];
// // let tokens = ["ape", "tree", "abc", "aaa", "bb", "ba", "ab", "abb", "bbb"];
// function START_BRAIN(){
//     AI_VIZ_LOG("----🧠 NN:INIT 🧠");
//     nn_1 = new NeuralNetwork_aZ_1(52, 10, 2); // 52 inputs (26 letters * 2 positions), 10 hidden neurons, 2 outputs

//     NNTXT_1_ELEM.innerHTML = tokens; //set tokens in UI.
//     // INPUT_1_ELEM.innerHTML = tokens; //set tokens in UI.

//     AI_VIZ_LOG("----🦾 NN:TRAIN_FRAME 🦾");
//     function trainExample() {
//         AI_VIZ_LOG("\n---💫 NN:TOKEN_LOOP 💫");
//         // Example: Train to recognize if a token contains double letters
//         tokens.forEach(token => {
//             AI_VIZ_LOG("---🗃️ INPUT_VECTORS 🗃️");
//             const input = nn_1.tokenToInput(token);//contains: VECTOR_DETECTOR.
//             AI_VIZ_LOG("---🎯 TARGET_CASE 🎯");
//             const target = [
//                 token[0] === token[1] ? 1 : 0,  // First NUM: has double letters
//                 token.includes('b') ? 1 : 0      // Second NUM: contains 'a'
//             ];
//             AI_VIZ_LOG("---🌪️ TRAIN_Fn 🌪️");
//             nn_1.train(input, target);
//             AI_VIZ_LOG("---🚧 END_TRAIN 🚧",token);
//         });
//     }

//     // Train the network
//     // debugger;
//     let epoch_num = 1000;
//     console.log('-----🌌 EPOCH_LOOP 🌌',epoch_num)
//     for (let i = 0; i < epoch_num; i++) {
//         trainExample();
//         if(i%(epoch_num*0.1)===0){ //ten epoch counters
//             AI_VIZ_LOG('-----🧭 EPOCH 🧭',i)
//         }
//     }

//     OUTPUT_1_ELEM.innerHTML = ''; //clear out put
//     // Test the network //optimize this TODO: move vars out to runFN() pattern.
//     console.log('TOKEN_INTELLIGENCE:[','double letter,','contains(b)')
//     tokens.forEach(token => {
//         const input = nn_1.tokenToInput(token);
//         const output = nn_1.forward(input);
//         console.log(`Token: ${token}, Output: ${output.map(v => v.toFixed(3))}`);
//         OUTPUT_1_ELEM.innerHTML = `Token: ${token}, Output: ${output.map(v => v.toFixed(3))}`
//         // debugger;
//         // const txtPCTS = output.map( (v) => { 
//         //     // return v.toFixed(3); 
//         //     return v.toFixed(2)*100;
//         //     // let decimal = v.toFixed(2)*100;
//         //     // return decimal.toFixed(0)+'%'; //human readable %
//         // });
//         // // const txtPCTS = txtTOKENS.split(',')
//         // if(txtPCTS[0]<txtPCTS[1]){//YES
//         //     OUTPUT_1_ELEM.innerHTML += `${token} || YES: ${txtPCTS[1]} || No: ${txtPCTS[0]}<br>`;
//         // } else { //NO
//         //     OUTPUT_1_ELEM.innerHTML += `${token} || no: ${txtPCTS[0]} || Yes: ${txtPCTS[1]}<br>`;
//         // }
//         // // OUTPUT_1_ELEM.innerHTML = `${token}||${txtROW}||${1234}`;
//     });
//     console.log('TOKEN_TEST:','EVAL: double letter and','contains(b)')
// }; START_BRAIN();


// Demonstration Function
// function demonstrateNeuralNetVisualization() {
//     // Tokens for demonstration
//     const tokens = ["hello", "help", "world", "code", "coding","aaa"];

//     const maxLength = 6;

//     // Create neural network
//     const nn = new NeuralNetwork(
//         maxLength,    // input size
//         6,            // hidden layer size
//         tokens.length // output layer size
//     );

//     // Create visualizerAI_BRAIN_VIZ
//     const AI_BRAIN_VIZ = new NeuralNetVisualizer(nn);

//     // 1. Initial Weight Visualization (Before Training)
//     //console.log("---🔬 VIZ: Neural Network State 🔬");
//     AI_BRAIN_VIZ.visualizeWeights();

//     // 2. Training and Visualization
//     tokens.forEach((token, index) => {
//         const input = nn.stringToOneHot(token, maxLength);
//         const target = new Array(tokens.length).fill(0);
//         target[index] = 1;

//         // Train network
//         for (let epoch = 0; epoch < 200; epoch++) {
//             nn.train(input, target, 0.05);
//         }
//     });

//     // 3. Visualization after Training
//     //console.log("\n---🦾 VIZ:WEIGHTS 🦾");
//     AI_BRAIN_VIZ.visualizeWeights();

//     // 4. Activation Visualization
//     //console.log("\n⚡ VIZ:ACTIVIATION ⚡");
//     const sampleInput = nn.stringToOneHot("hello", maxLength);
//     AI_BRAIN_VIZ.visualizeActivations(sampleInput);

//     // 5. Learning Trajectory
//     //console.log("\n---🚀 VIZ:TRAJECTORY 🚀");
//     AI_BRAIN_VIZ.visualizeLearningTrajectory(tokens, maxLength);
// }
// debugger;
// Run the visualization demonstration
// demonstrateNeuralNetVisualization();

// Token: aa, Output: 0.955,0.030
// Token: ab, Output: 0.027,0.982
// Token: abc, Output: 0.027,0.982
// Token: aaa, Output: 0.955,0.030
// Token: bb, Output: 0.936,0.999
// Token: ba, Output: 0.101,0.951
// Token: ab, Output: 0.027,0.982
// Token: abb, Output: 0.027,0.982
// Token: bbb, Output: 0.936,0.999