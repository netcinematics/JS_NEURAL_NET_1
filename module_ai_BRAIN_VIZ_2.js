
// ************* AI - NEOLOGISM EXPERIMENT ****************
// MINIMAL Neural Network example, for wordcrafting study.
//   - generated by Claude, revised by Gemini.
//   - trains an NN then AFFIRMS presence in nn.
//------------------------------------------------------
// VARIANT: 10X10 aZ targets (sigmoid pre relu)
// - with LOCAL VIZ module, variations.
// - ADD: TRAIN BTN and COMBOS for LR and EPOCH
// - ADD: 10 FRAME TIMELINE - METADATA.
// - USE: 10 FRAME DATA for AI_MOVIE.
// TODO: -------------------------------
// X - AI_HYPER_PARAMS
// X - AI_BRAINZ (meta data)
// X - AI_TIMELINE
// X - AI_MOVIE
// -------------------------
// O - dimension analysis
// O - backtrace answers (try to label tknz/tgtz)
//----------------------UI-VARIABLES--------------
const NNTXT_1_ELEM = document.getElementById("NNTXT_1_ELEM");
const OUTPUT_1_ELEM = document.getElementById("OUTPUT_1_ELEM");
const TXT_INPUT_1_ELEM = document.getElementById('TXT_INPUT_1_')
// const TEST_BTN_1_ELEM = document.getElementById('TEST_BTN_1_')
//-----------------------------------------------
//------------------------VISUALIZATION-----------
import { AI_VIZ_LOG } from './module_AI_VIZ_LOG_1.js'; 
// import { AI_BRAIN_VIZ_1 } from './module_ai_BRAIN_VIZ_1.js';//todo?

//-----------------------------------------------
class NeuralNetwork_aZ_1 {
    constructor(inputSize,learnRate,epochLIMIT) {
        // Making square matrices (equal dimensions)
        this.inputSize = inputSize; //DIMZ:
        this.hiddenSize = inputSize; //DIMZ: 
        this.outputSize = 2;  //DIMZ: 2 TGTZ - starts with 'a' and contains uppercase

        // Initialize weights with improved initial values for better convergence
        this.weightsIH = this.initializeWeights(this.inputSize, this.hiddenSize, 0.3);
        this.weightsHO = this.initializeWeights(this.hiddenSize, this.outputSize, 0.3);
        
        // Initialize biases with small positive values
        this.biasH = new Array(this.hiddenSize).fill(0.1);
        this.biasO = new Array(this.outputSize).fill(0.1);
        
        console.log('LEARN RATE',learnRate)
        // Learning parameters
        this.learningRate = (learnRate)?learnRate:0.15;  // Tuned for better convergence
        this.epochLIMIT = epochLIMIT; //pass through to VIZ.
        this.epochIDX = 0; //for timeline
        this.IH_SLICE = []; //for timeline
    }

    // Initialize weights with Xavier initialization
    initializeWeights(rows, cols, scale) {
        const weights = [];
        for (let i = 0; i < rows; i++) { //DIMZ: 
            weights[i] = [];
            for (let j = 0; j < cols; j++) { //DIMZ:
                // Xavier initialization: variance of weights based on layer size
                weights[i][j] = (Math.random() * 2 - 1) * Math.sqrt(scale / rows);
            }
        }
        return weights;
    }

    // Sigmoid activation function
    sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
    }

    // Derivative of sigmoid for backpropagation
    sigmoidDerivative(x) {
        return x * (1 - x);
    }

    // Convert word to input vector (using ASCII values normalized)
    wordToInput(word, size) {
        const input = new Array(size).fill(0);
        for (let i = 0; i < Math.min(word.length, size); i++) {
            input[i] = word.charCodeAt(i) / 255;  // Normalize ASCII values
        }
        return input;
    }

    // Forward pass through the network
    forward(input) {
        // Hidden layer computations
        this.hiddenLayer = new Array(this.hiddenSize).fill(0);
        for (let i = 0; i < this.hiddenSize; i++) { //DIMZ:
            let sum = this.biasH[i];
            for (let j = 0; j < this.inputSize; j++) { //DIMZ:
                sum += input[j] * this.weightsIH[j][i];
            }
            this.hiddenLayer[i] = this.sigmoid(sum);
        }

        // Output layer computations
        this.outputLayer = new Array(this.outputSize).fill(0);
        for (let i = 0; i < this.outputSize; i++) { //DIMZ:
            let sum = this.biasO[i];
            for (let j = 0; j < this.hiddenSize; j++) { //DIMZ:
                sum += this.hiddenLayer[j] * this.weightsHO[j][i];
            }
            this.outputLayer[i] = this.sigmoid(sum);
        }

        return this.outputLayer;
    }

    // Backward pass for training
    backward(input, target, output) {
        // Output layer error: DIMZ: 2X2 -
        const outputErrors = new Array(this.outputSize);
        for (let i = 0; i < this.outputSize; i++) {
            outputErrors[i] = (target[i] - output[i]) * this.sigmoidDerivative(output[i]);
        }

        // Hidden layer error: DIMZ: 10X1 - 
        const hiddenErrors = new Array(this.hiddenSize).fill(0);
        for (let i = 0; i < this.hiddenSize; i++) {
            for (let j = 0; j < this.outputSize; j++) {
                hiddenErrors[i] += outputErrors[j] * this.weightsHO[i][j];
            }
            hiddenErrors[i] *= this.sigmoidDerivative(this.hiddenLayer[i]);
        }

        // Update weights and biases-------------------------------------
        // HO: Hidden to output weights: DIMZ: 10X2 - 
        for (let i = 0; i < this.hiddenSize; i++) {
            for (let j = 0; j < this.outputSize; j++) {
                this.weightsHO[i][j] += this.learningRate * outputErrors[j] * this.hiddenLayer[i];
            }
        }

        // IH: Input to hidden weights: DIMZ: 10X10 - 
        for (let i = 0; i < this.inputSize; i++) {
            for (let j = 0; j < this.hiddenSize; j++) {
                this.weightsIH[i][j] += this.learningRate * hiddenErrors[j] * input[i];
            }
        }

        // BIAS: Update biases Output & Hidden:DIMZ: 1X2 -
        for (let i = 0; i < this.outputSize; i++) {
            this.biasO[i] += this.learningRate * outputErrors[i];
        }
        for (let i = 0; i < this.hiddenSize; i++) { //DIMZ:1X10 -
            this.biasH[i] += this.learningRate * hiddenErrors[i];
        }
    }

    // Training function, 
    //DIMZ: inputs: 15X10 
    //    - targets: 15X2 - 
    train(inputs, targets, epochs) {
        const errors = [];
        AI_VIZ_LOG('>   🌌 EPOCH_LOOP 🌌',epochs);
        for (let epoch = 0; epoch < epochs; epoch++) {
            this.epochIDX = epoch; //used for epoch_rate timeline
            let epochError = 0;
            for (let i = 0; i < inputs.length; i++) { //DIMZ:
                const output = this.forward(inputs[i]);
                this.backward(inputs[i], targets[i], output);
                for (let j = 0; j < this.outputSize; j++) { // Calculate mean squared error
                    epochError += Math.pow(targets[i][j] - output[j], 2);
                }
            }

            //------------- EPOCH_SNAPSHOT!------------------------------
            //AI_VIZ_LOG('-----🧭 EPOCH 🧭',i)
            if( this.epochIDX % (this.epochLIMIT * 0.1) === 0){ //ten EPOCH_SLICES.
                //TODO map map map?
                // Capture initial weights
                // weightTrajectory.inputHidden.push(
                //     this.neuralNet.inputHiddenWeights.map(row => row.map(val => val))
                // );
                // weightTrajectory.hiddenOutput.push(
                //     this.neuralNet.hiddenOutputWeights.map(row => row.map(val => val))
                // );            
                let copySlice = JSON.parse(JSON.stringify(this.weightsIH)); //same
                this.IH_SLICE.push(copySlice); //for timeline
            }

            epochError /= inputs.length;
            errors.push(epochError);
            
            // Early stopping if error is small enough
            if (epochError < 0.001) break;
        } //END EPOCH_LOOP
        return errors; 
    }

    visualize() { // Visualize network state : improved to heatmap.
        console.log("\nNeural Network State:");
        console.log("Input -> Hidden Weights:");
        console.log(this.weightsIH.map(row => row.map(w => w.toFixed(3))));
        console.log("\nHidden -> Output Weights:");
        console.log(this.weightsHO.map(row => row.map(w => w.toFixed(3))));
        console.log("\nHidden Biases:", this.biasH.map(b => b.toFixed(3)));
        console.log("Output Biases:", this.biasO.map(b => b.toFixed(3)));
    }

} //END NEURAL NETWORK class

// function queryNeuralNetwork_1_(e){
    // if(!TXT_INPUT_1_ELEM){console.log('err: missing input'); return}
    // const val = TXT_INPUT_1_ELEM.value;
    // if(!val){console.log('needs input'); return;}
    // tokens = val.split(' '); // MULTIPLE INPUT (token test) BY SPACE
    // OUTPUT_1_ELEM.innerHTML = ''; //clear out put
    // tokens.forEach(token => {
    //     const input = nn_1.tokenToInput(token);
    //     const output = nn_1.forward(input);
    //     console.log(`Token: ${token}, Output: ${output.map(v => v.toFixed(3))}`);
    //     const txtPCTS = output.map( (v) => { 
    //         // return v.toFixed(3); 
    //         return v.toFixed(2)*100;
    //         // let decimal = v.toFixed(2)*100;
    //         // return decimal.toFixed(0)+'%'; //human readable %
    //     });
    //     // const txtPCTS = txtTOKENS.split(',')
    //     if(txtPCTS[0]<txtPCTS[1]){//YES
    //         OUTPUT_1_ELEM.innerHTML += `${token} || NO: ${txtPCTS[1]} || yes: ${txtPCTS[0]}<br>`;
    //     } else { //NO
    //         OUTPUT_1_ELEM.innerHTML += `${token} || YES: ${txtPCTS[0]} || no: ${txtPCTS[1]}<br>`;
    //     }
    //     // OUTPUT_1_ELEM.innerHTML = `${token}||${txtROW}||${1234}`;
    // });
// }
// TEST_BTN_1_ELEM.onclick = queryNeuralNetwork_1_;
//-----------END UI-----------------------------
//-----------AI RUNNER-----------------------------
// Test the neural network
let nn;//connect to viz.
function testNetwork() {
    // Create training data
    const trainingWords = [
        "apple", "Banana", "cat", "Dog", "elephant",
        "art", "Book", "car", "Door", "egg",
        "another", "CAPS", "simple", "Test", "animal"
    ];

    //----TUNABLE---HYPER_PARAMS:-----------------
    const learnRate = 0.1544;
    const epoch_NUM = 10000; 
    const inputSize = 10;  // DIMZ: 10 - number of letters, to square matrix.
    debugger;
    nn = new  NeuralNetwork_aZ_1(inputSize, learnRate, epoch_NUM);

    AI_VIZ_LOG("> _🧩 TOKEN_SET 🧩:",trainingWords);
    const inputs = trainingWords.map(token => nn.wordToInput(token, inputSize));
    const targets = trainingWords.map(token => [
        token.startsWith('a') ? 1 : 0,
        /[A-Z]/.test(token) ? 1 : 0
    ]); //TODO extend with count>3 and ends with little a.
    AI_VIZ_LOG(">   🎯 SET 2 TARGETS 🎯:",'start_a','anyUpper');
    AI_VIZ_LOG(">   🦾 NN:TRAIN_FRAME 🦾");
    const errors = nn.train(inputs, targets, epoch_NUM);
    AI_VIZ_LOG(">   🚧 END_TRAIN 🚧");
    console.log("Final error:", errors[errors.length - 1]);

    //TODO: backtrack...correct answer, to decipher dimension alignments.
    debugger;
    // Test the network
    const testWords = ["amazing", "and", "zebra", "Apple", "test"];
    let msg = '';
    AI_VIZ_LOG("> _🧩 TEST_TOKENS 🧩:",testWords);
    for (const word of testWords) {
        const input = nn.wordToInput(word, inputSize);
        const output = nn.forward(input);
        AI_VIZ_LOG("Word: ",word);
        msg = `Starts with 'a': ${output[0].toFixed(3)} (Expected: ${word.startsWith('a') ? 1 : 0})`;
        AI_VIZ_LOG(msg);
        msg = `Contains uppercase: ${output[1].toFixed(3)} (Expected: ${/[A-Z]/.test(word) ? 1 : 0})`;
        AI_VIZ_LOG(msg);
    }

    // Visualize the final state
    // nn.visualize(); //replaced.
}
// Run the test
testNetwork();
//-----------END AI RUNNER-----------------------------
//----------- AI_BRAIN_VIZ-----------------------------
export class AI_BRAIN_VIZ_2 {
    constructor(neuralNet) {
        AI_VIZ_LOG(">  🧠 NN:INIT 🧠");
        if(!neuralNet){console.log('err: no network')}
        this.neuralNet = neuralNet;

        this.CANVAS_BRAIN_VIZ_1 = document.getElementById('CANVAS_BRAIN_VIZ_1');
        this.CANVAS_TIMELINE_1 = document.getElementById('CANVAS_TIMELINE_1');
        this.CANVAS_PLAYBACK_1 = document.getElementById('CANVAS_PLAYBACK_1');
        this.CANVAS_3D_MATRIX_1 = document.getElementById('CANVAS_3D_MATRIX_1');
        this.TXT_AI_VIZ_LOG_1 = document.getElementById('TXT_AI_VIZ_LOG_1');

        if(!CANVAS_BRAIN_VIZ_1){console.log('err: no CANVAS_BRAIN_VIZ_1')}
        this.CANVAS_BRAIN_VIZ_1 = CANVAS_BRAIN_VIZ_1;//document.getElementById(canvasId);
        this.ctx_BRAIN_VIZ = this.CANVAS_BRAIN_VIZ_1.getContext('2d');

        if(!CANVAS_TIMELINE_1){console.log('err: no CANVAS_TIMELINE_1')}
        this.CANVAS_TIMELINE_1 = CANVAS_TIMELINE_1;//document.getElementById(canvasId);
        this.ctx_TIMELINE = this.CANVAS_TIMELINE_1.getContext('2d');
    }
    
    // render_BASELINE(epochz = []) { //TODO: timeline
    //     // Clear the canvas
    //     // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    //     // this.canvas.width = (epochz.length)?epochz.length*100:300;
    //     // Draw base timeline
    //     this.ctx.beginPath();
    //     this.ctx.strokeStyle = 'steelblue';
    //     this.ctx.lineWidth = 1;
    //     this.ctx.moveTo(25, this.canvas.height * 0.6 );
    //     this.ctx.lineTo(this.canvas.width - 25, this.canvas.height * 0.6 );
    //     this.ctx.stroke();

    //     let epoch = {};
    //     for(var i=0; i<epochz.length;i++){
    //         epoch = epochz[i];
    //         // console.log('EPOCH',epoch.title,(i+1)*10)
    //         this.DRAW_VERTICAL_LINE(((i+1)*100)+14);
    //         // this.DRAW_VERTICAL_LINE(epoch.x);
    //         // this.DRAW_POINT(epoch.x, epoch.y, epoch.emoji);
            
    //     }

    // }

    // DRAW_VERTICAL_LINE(x) {
    //     this.ctx.beginPath();
    //     this.ctx.strokeStyle = 'steelblue';
    //     this.ctx.moveTo(x, this.canvas.height * 0.6 - 10 );
    //     this.ctx.lineTo(x, this.canvas.height * 0.6 + 10);
    //     this.ctx.lineWidth = 1;
    //     this.ctx.stroke();
    // }

    render_NEURON_TIMELINE(){ //AI_TIMELINE VIZ.
            
        if(!nn.IH_SLICE){console.log('ERROR: cannot find slice!');return;}
        this.ctx_TIMELINE.clearRect(0, 0, this.CANVAS_TIMELINE_1.width, this.CANVAS_TIMELINE_1.height);  // Clear the canvas
        this.CANVAS_TIMELINE_1.width = (nn.IH_SLICE.length)?nn.IH_SLICE.length*100:this.CANVAS_TIMELINE_1.width;
        let frame=[],vector=[],colorTGT=0;
        let row=0,cols=0;
        let SIZE_SML=2,SIZE_MED=3,SIZE_BIG=4,SPACING_SML=6,SPACING_MED=7,SPACING_BIG=8;
        let startX=0,startY=0,colorVal='';;

        let PAD_TOP = 25;
        let PAD_LEFT = 20;
        let PAD_COL = 100;

        let CURSOR_POS = {x:PAD_LEFT,y:PAD_TOP}; //USE like a ink printer.
        this.ctx_TIMELINE.fillStyle = 'steelblue';
        this.ctx_TIMELINE.font = "0.8em Arial italic bold "; //TITLE
        this.ctx_TIMELINE.fillText("HIDDEN NEURONS:", CURSOR_POS.x, CURSOR_POS.y);

        CURSOR_POS = {x:PAD_LEFT,y:40}; //NEXT POSITION.
        let slice, colorGrid;
        for(let i=0;i<nn.IH_SLICE.length;i++){
            slice = nn.IH_SLICE[i];
            colorGrid = this.matrixToColorsNormalized(slice);

            CURSOR_POS = {x:(PAD_COL*i)+PAD_LEFT, y:CURSOR_POS.y}; //NEXT POSITION.
            for (let rowIDX = 0; rowIDX < colorGrid.length; rowIDX++) {
                row = colorGrid[rowIDX];
                cols = row.length;
                startX = CURSOR_POS.x + (rowIDX*SPACING_MED); 
                for (let colIDX = 0; colIDX < row.length; colIDX++) {
                    colorTGT = row[colIDX];
                    startY = CURSOR_POS.y + (colIDX * SPACING_MED);
                    this.ctx_TIMELINE.beginPath();
                    this.ctx_TIMELINE.fillStyle = colorTGT;
                    this.ctx_TIMELINE.arc(startX,startY,SIZE_MED, 0, Math.PI * 2);
                    this.ctx_TIMELINE.fill();
                }
            }
        }
    }
    render_NEURON_WEIGHTS(){ //NEURON_WEIGHT VIZ.
        // NN_MIN1:biasH, biasO, hidden, learningRate, output, weightsHO, weightsIH
        let frame=[],vector=[],scalar=0;
        let rows=0,cols=0;
        let SIZE_SML=2,SIZE_BIG=4,SPACING_SML=6,SPACING_BIG=8;
        let startX=0,startY=0,colorVal='';;

        let PAD_TOP = 25;
        let PAD_LEFT = 20;
        let CURSOR_POS = {x:PAD_LEFT,y:PAD_TOP}; //USE like a ink printer.

        this.ctx_BRAIN_VIZ.fillStyle = 'steelblue';
        this.ctx_BRAIN_VIZ.font = "0.8em Arial italic bold "; //TITLE
        this.ctx_BRAIN_VIZ.fillText("NEURON IH:", CURSOR_POS.x, CURSOR_POS.y);

        CURSOR_POS = {x:166,y:18}; //NEXT POSITION.

        rows = this.neuralNet.weightsIH.length;
        for (let frameIDX = 0; frameIDX < this.neuralNet.weightsIH.length; frameIDX++) {
            frame = this.neuralNet.weightsIH[frameIDX];
            cols = frame.length;
            startX = CURSOR_POS.x + (frameIDX*SPACING_BIG); 
            for (let vectorIDX = 0; vectorIDX < frame.length; vectorIDX++) {
                vector = frame[vectorIDX];
                startY = CURSOR_POS.y + (vectorIDX * SPACING_BIG);
                colorVal = this.getColor_MAP_1(vector,-1,1)
                this.ctx_BRAIN_VIZ.beginPath();
                this.ctx_BRAIN_VIZ.fillStyle = colorVal;
                this.ctx_BRAIN_VIZ.arc(startX, startY,SIZE_BIG, 0, Math.PI * 2);
                this.ctx_BRAIN_VIZ.fill();
            }
        }
        CURSOR_POS = {x:PAD_LEFT,y:66}; //NEXT POSITION.
        this.ctx_BRAIN_VIZ.fillStyle = 'steelblue';
        this.ctx_BRAIN_VIZ.font = "0.8em Arial italic bold "; //TITLE
        this.ctx_BRAIN_VIZ.fillText("NEURON HO:",CURSOR_POS.x,CURSOR_POS.y);
        CURSOR_POS = {x:PAD_LEFT+20,y:60}; //NEXT POSITION.
        rows = this.neuralNet.weightsHO.length;
        for (let frameIDX = 0; frameIDX < this.neuralNet.weightsHO.length; frameIDX++) {
            frame = this.neuralNet.weightsHO[frameIDX];
            cols = frame.length;
            startX = CURSOR_POS.x + (frameIDX*SPACING_SML);// + CURSOR_POS.x; 
            for (let vectorIDX = 0; vectorIDX < frame.length; vectorIDX++) {
                vector = frame[vectorIDX];
                startY = PAD_TOP + (vectorIDX * SPACING_SML) +CURSOR_POS.y;
                colorVal = this.getColor_MAP_1(vector,-1,1)
                this.ctx_BRAIN_VIZ.beginPath();
                this.ctx_BRAIN_VIZ.fillStyle = colorVal;
                this.ctx_BRAIN_VIZ.arc(startX, startY,SIZE_SML, 0, Math.PI * 2);
                this.ctx_BRAIN_VIZ.fill();
            }
        }        
        this.ctx_BRAIN_VIZ.fillStyle = 'steelblue';
        this.ctx_BRAIN_VIZ.font = "0.8em Arial italic bold "; //TITLE
        this.ctx_BRAIN_VIZ.fillText("BIAS(hidden):", PAD_LEFT, 120);

        CURSOR_POS = {x:166,y:120}; //NEXT POSITION.
        rows = 1;
        for (let vectorIDX = 0; vectorIDX < this.neuralNet.biasH.length; vectorIDX++) {
            scalar = this.neuralNet.biasH[vectorIDX];
            startX = CURSOR_POS.x + vectorIDX * SPACING_SML;
            startY = CURSOR_POS.y;
            colorVal = this.getColor_MAP_1(scalar,-1,1)
            this.ctx_BRAIN_VIZ.beginPath();
            this.ctx_BRAIN_VIZ.fillStyle = colorVal;
            this.ctx_BRAIN_VIZ.arc(startX, startY,SIZE_SML, 0, Math.PI * 2);
            this.ctx_BRAIN_VIZ.fill();
        }
    }

    getColor_MAP_1 (value, min, max){ // Map value to color intensity
        const normalized = (value - min) / (max - min);
        let r = Math.floor(255 * (1 - normalized));
        let b = Math.floor(255 * normalized);
        r = (r<0)?0:r;
        b = (b<0)?0:b;
        return (value===0)?'black':(b>r)?'blue':'red';
    }

    numbersToColorsNormalized(nums) {
        if (!nums || nums.length === 0) {
          return []; // Handle empty or null input
        }
      
        // Find min and max values for normalization
        let minVal = Math.min(...nums);
        let maxVal = Math.max(...nums);
      
        // Handle the edge case where all numbers are the same.
        if (minVal === maxVal) {
          return nums.map(() => 'rgb(128, 0, 128)'); // Return a default color (purple)
        }
      
        return nums.map(num => {
          // Normalize the number to the range 0-1
          let normalized = (num - minVal) / (maxVal - minVal);
      
          let r = 0;
          let g = 0;
          let b = 0;
      
          // Interpolate between red and blue based on the normalized value
          r = Math.round(255 * (1 - normalized)); // Red decreases as normalized increases
          b = Math.round(255 * normalized);      // Blue increases as normalized increases
      
          return `rgb(${r}, ${g}, ${b})`;
        });
    }


    matrixToColorsNormalized(matrix) {
        if (!matrix || matrix.length === 0 || !matrix.some(row => row.length > 0)) {
          return []; // Handle empty or invalid input, including empty rows
        }
      
        // Flatten the matrix to find min and max values efficiently
        const flattened = matrix.flat();
        const minVal = Math.min(...flattened);
        const maxVal = Math.max(...flattened);
      
        // Handle the edge case where all numbers are the same
        if (minVal === maxVal) {
          return matrix.map(row => row.map(() => 'rgb(128, 0, 128)')); // Default to purple
        }
      
        return matrix.map(row =>
          row.map(num => {
            const normalized = (num - minVal) / (maxVal - minVal);
            const r = Math.round(255 * (1 - normalized));
            const b = Math.round(255 * normalized);
            return `rgb(${r}, 0, ${b})`;
          })
        );
      }

    numberToColor(num) {
        let min = -1, max = 1;
        const normalized = (num - min) / (max - min);
        let r = Math.floor(255 * (1 - normalized));
        let b = Math.floor(255 * normalized);
        let g = 0;

        if (num >= 0 && num <= 1) {  // Blue shades (0 to 1)
        b = Math.round(255 * num);
        } else if (num >= -1 && num < 0) { // Red shades (-1 to 0)
        r = Math.round(255 * Math.abs(num)); // Use absolute value for positive red
        } else if (num > 1) {         // Green
        g = 255;
        } else if (num < -1) { // Purple (mix of red and blue)
        r = 128; // Half red
        b = 128; // Half blue
        }
        return `rgb(${r}, ${g}, ${b})`;
    }

    // DRAW_GRID(grid = {rows : 14, cols : 14, startX : 30, startY : 30, spacing : 4} ) {
    //     // console.log('grid', rows, cols, startX, startY, spacing);
    //     for (let row = 0; row < grid.rows; row++) {
    //         this.DRAW_VECTOR(
    //             grid.startX, 
    //             grid.startY + row * grid.spacing, 
    //             grid.cols, 
    //             grid.spacing
    //         );
    //     }
    // }

    // DRAW_VECTOR(startX, startY, count = 10, spacing = 10) {
    //     // console.log('vector', startX, startY, count, spacing);
    //     for (let i = 0; i < count; i++) {
    //         this.DRAW_POINT( startX + i * spacing, startY   );
    //     }
    // }

    // DRAW_POINT(x, y) {
    //     // console.log('point',x,y)
    //     this.ctx.beginPath();
    //     this.ctx.fillStyle = 'blue';
    //     this.ctx.arc(x, y, 1, 0, Math.PI * 2);
    //     this.ctx.fill();
    // }
    
    // DRAW_EMOJI(x, y, emoji) {
    //     console.log('emoji',x,y)
    //     // Draw emoji
    //     this.ctx.font = '12px Arial';
    //     this.ctx.fillStyle = 'white'; // Ensure visibility on black background
    //     // this.ctx.textAlign = 'center';
    //     this.ctx.fillText(emoji, x, y);
    // }
    // render_TIMELINE_SLICE(canvas, txt){
    render_TIMELINE_SLICE(canvas, idx){ //MOVIE PLAYBACK
        let ctx_PLAYBACK = canvas.getContext('2d');
        ctx_PLAYBACK.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas
        let dataframe = AI_BRAIN_VIZ.neuralNet.IH_SLICE[idx];
        if(!dataframe){console.log('ERROR: no dataframe');return;}
        let colorTGT=0;
        let row=0;//,cols=0;
        let SIZE_SML=2,SIZE_MED=3,SIZE_BIG=4,SPACING_SML=6,SPACING_MED=7,SPACING_BIG=8;
        let startX=0,startY=0,colorVal='';;

        let PAD_TOP = 25;
        let PAD_LEFT = 20;

        let CURSOR_POS = {x:PAD_LEFT,y:PAD_TOP}; //USE like a ink printer.
        ctx_PLAYBACK.fillStyle = 'steelblue';
        ctx_PLAYBACK.font = "0.8em Arial italic bold "; //TITLE
        ctx_PLAYBACK.fillText("TRAIN NEURONS:", CURSOR_POS.x, CURSOR_POS.y);

        let colorGrid = this.matrixToColorsNormalized(dataframe);

        CURSOR_POS = {x:PAD_LEFT+44, y:44}; //NEXT POSITION.
        for (let rowIDX = 0; rowIDX < colorGrid.length; rowIDX++) {
            row = colorGrid[rowIDX];
            startX = CURSOR_POS.x + (rowIDX*SPACING_BIG); 
            for (let colIDX = 0; colIDX < row.length; colIDX++) {
                colorTGT = row[colIDX];
                startY = CURSOR_POS.y + (colIDX * SPACING_BIG);
                ctx_PLAYBACK.beginPath();
                ctx_PLAYBACK.fillStyle = colorTGT;
                ctx_PLAYBACK.arc(startX,startY,SIZE_BIG, 0, Math.PI * 2);
                ctx_PLAYBACK.fill();
            }
        }//end loop
    }//end playback
} //END AI_BRAIN_VIZ class
//-----------------------------LOCAL MODULE: 
let AI_BRAIN_VIZ; //- add vis features here, then export to module.
function RENDER_BRAIN_VIZ(){ //VIZ MODULE---------RUNNER--------------
    AI_BRAIN_VIZ = new AI_BRAIN_VIZ_2(nn);
    // 1. Initial Weight Visualization (Before Training)
    AI_VIZ_LOG(">  🔬 VIZ_LOG: of AI_BRAINZ 🔬");
    AI_BRAIN_VIZ.render_NEURON_WEIGHTS(); //visualizeWeights
    AI_BRAIN_VIZ.render_NEURON_TIMELINE();
}; RENDER_BRAIN_VIZ();
//-----------END AI VIZ-----------------------------
//---------------DYNAMIC-PLAYBACK - UI--------(zero footprint in html)
const playback_BTN_1_ = document.getElementById('playback_BTN_1_');
const playback_idx_1_ = document.getElementById('playback_idx_1_');
const playback_total_1_ = document.getElementById('playback_total_1_');
playback_BTN_1_.onclick = (e) => { //toggle button
    const CANVAS_PLAYBACK_1 = document.getElementById('CANVAS_PLAYBACK_1');
    if(playback_BTN_1_.innerText.indexOf('PLAY')>-1){
        playback_BTN_1_.innerText = '⏸ PAUSE';
        start_CANVAS_PLAYBACK(CANVAS_PLAYBACK_1);
    } else {
        playback_BTN_1_.innerText = '▶️ PLAY';
        stop_CANVAS_PLAYBACK(CANVAS_PLAYBACK_1);
    } 
}
//-----------------------PLAYBACK-LOGIC------------------------
let intervalId;
let currentIndex = 0;
function start_CANVAS_PLAYBACK(canvas){
    if(!AI_BRAIN_VIZ.neuralNet){console.log('ERROR: no neural net'); return;}
    if(!AI_BRAIN_VIZ.neuralNet.IH_SLICE.length){console.log('ERROR: no neural net'); return;}
    let loopCount = 0;
    const maxLoops = 10; // Number of loops before stopping
    intervalId = setInterval(() => {
        AI_BRAIN_VIZ.render_TIMELINE_SLICE(canvas, currentIndex);
        currentIndex = (currentIndex + 1) % AI_BRAIN_VIZ.neuralNet.IH_SLICE.length; // Cycle through the array
        playback_idx_1_.innerText = currentIndex;
        playback_total_1_.innerText = AI_BRAIN_VIZ.neuralNet.IH_SLICE.length;
        loopCount++;
        if (loopCount >= maxLoops+1) {
            playback_BTN_1_.innerText = '▶️ PLAY';
            clearInterval(intervalId); // Stop the interval
            console.log("Playback stopped at limit.");
        }
    }, 1000); // 1000 milliseconds = 1 second
}
function stop_CANVAS_PLAYBACK(canvas){
    console.log("Stopped Playback.");
    clearInterval(intervalId); // Stop the interval
}
//-----------END VIZ UI-----------------------------
